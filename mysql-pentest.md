
# Ethical MySQL / MS-SQL Pentest: Step by step (lab only)

## 0. Legal & safety first

0. These materials are for education and research purposes only, in lab and testing environment only, with no liability of any kind.
1. Testers must always get **written and signed permission** before running any pentest.
2. Always work on copies/staging or an isolated hackme VPS/VM/container.
3. Prefer non-destructive techniques first (enumeration, read-only checks).
4. Keep an auditable log of commands and findings.

---

## 1. Recon: find MySQL service and exposure

* Port scan for MySQL (default 3306):

```bash
# quick check
nmap -sV -p 3306 target.example.com

# Use Nmap’s MySQL scripts to gather version info and check for weak credentials or anonymous access (safe for labs only).
nmap -sV --script mysql-info,mysql-enum -p 3306,33060 target.example.com

# Full TCP scan for nonstandard ports (if needed)
nmap -sS -p 1-10000 target.example.com

```


* Check for management UIs (phpMyAdmin, Adminer) by crawling common paths:

```bash
curl -sI https://target.example.com/phpmyadmin
curl -sI https://target.example.com/adminer.php
curl -sI https://target.example.com/.git/config  # Check for exposed Git repos
```

* Instead of manual curl checks for phpMyAdmin/Adminer, you might use lightweight web scanners like gobuster. This automates discovery of admin interfaces or config files.

```
gobuster dir -u https://target.example.com -w /usr/share/wordlists/dirb/common.txt -x php,html
```

---

## 2. Find credentials & config leaks (passive first)

* Look for exposed config files from webroot (WordPress / other PHP apps):

```bash
# on the server (if you have access)
grep -R "DB_PASSWORD" /var/www/html || true
grep -R "DB_USER" /var/www/html || true

# Or use regex for broader coverage.
grep -RiE "DB_PASSWORD|password|db_pass|db_user" /var/www/html || true


# HTTP checks (publicly visible files)
curl -sI https://target.example.com/wp-config.php
curl -sI https://target.example.com/.env
curl -sI https://target.example.com/wp-config.php.bak
```

* Search for SQL dumps/backups in webroot:

```bash
find /var/www/html -type f -iname '*.sql' -o -iname '*.sql.gz'
```

Note: Passive discovery often reveals the easiest access vectors—exposed `wp-config.php`, `.env`, old backups, consult [wp-pentest.md](https://github.com/roverbird/cybersec/blob/main/wp-pentest.md)

* Git Exposure: Check exposed .git directories that might contain configs or backups.
```
curl -sI https://target.example.com/.git/config
```

* If you have ssh access, verify file permissions for sensitive files like `wp-config.php` or `.env`.

```
ls -l /var/www/html/wp-config.php  # Should be 640 or 600
```

---

## 3. Attempt safe connections (only with creds / in lab)

* If you have DB creds from config (lab), connect with MySQL client:

```bash
mysql -u dbuser -p -h 127.0.0.1 -P 3306    # local
mysql -u dbuser -p -h 10.0.0.5 -P 3306     # remote (lab)
```

* This andles connection errors

```bash
mysql -u dbuser -p -h 127.0.0.1 -P 3306 --connect-timeout=10
```


* Basic enumeration after login (read-only):

```sql
SHOW DATABASES;
USE wordpress;           -- example
SHOW TABLES;
SELECT COUNT(*) FROM wp_users;
SELECT user_login, user_email FROM wp_users LIMIT 10;
```
* Check if the MySQL server supports TLS during enumeration.

```sql
SHOW VARIABLES LIKE 'have_ssl';
SHOW VARIABLES LIKE 'have_openssl';
```

Always avoid destructive SQL (no DROP, DELETE, UPDATE) unless explicitly part of an agreed exercise.

---

## 4. Web-app SQL injection (lab only): reconnaissance & non-destructive checks

* Identify injectable parameters: form fields, search, REST endpoints, `?id=`, etc.
* Use safe, automated detection first (use low risk/level):
* sqlmap, even at low risk, can generate significant traffic: In our lab, we ensure the sandbox target is isolated and monitored to avoid unintended load or disruption.

```bash
# sqlmap example (lab only)
sqlmap -u "http://localhost:8080/?id=1" --batch --level=1 --risk=1 --technique=T --crawl=0 --answers="follow=N"

# you can explicitly disable --os-shell and --sql-shell to avoid accidental escalation; --no-cast reduces query complexity, and --skip-waf avoids WAF-related issues.
sqlmap -u "http://localhost:8080/?id=1" --batch --level=1 --risk=1 --technique=T --dbs --no-cast --skip-waf

```

* Prefer `--technique=T` (time-based) or `-p` to focus; start with `--dbs` or `--tables` and avoid `--os-shell`/`--sql-shell` unless in controlled exercise.

* Simple manual SQL injection test before using automated tools:

```bash
# Test for basic SQLi (time-based)
curl "http://localhost:8080/?id=1 AND SLEEP(5)"
```

* What it does: If a web application unsafely inserts the id value directly into an SQL query, supplying ?id=1 AND SLEEP(5) can make the database pause for 5 seconds before returning results. That delay shows up as a noticeably slower HTTP response, a reliable sign the id parameter is being used in an SQL context and is injectable (blind SQLi).

`SLEEP(5)` is a MySQL function (pauses for 5 seconds). Other databases use different functions (PostgreSQL: `pg_sleep(5)`, SQL Server: `WAITFOR DELAY '00:00:05'`).

Tester compares response time of a normal request (e.g. `?id=1`) to one with the `SLEEP(5)` fragment. If the latter is ~5s slower, that’s strong evidence of vulnerability. Tools that detect blind SQLi use the same principle (timing differences) to confirm injection when no visible error or output is returned.

---

## 5. If you get DB access: ethical post-access steps

* **Enumerate, do not modify** (unless exercise requires):

  * List databases, list tables, sample rows from non-sensitive tables.
* **Document everything**: queries run, outputs, timestamps, how credentials were obtained.
* **Demonstrate impact** by non-destructive examples (e.g., read users table, show plugin option entries) rather than altering data.

---

## 6. Privilege escalation checks (lab only)

* Check current DB user privileges:

```sql
SHOW GRANTS FOR CURRENT_USER;
```

* If user is too privileged in lab, look into Principle of Least Privilege and remediation.

* Check MySQL Version for known vulnerabilities (e.g., CVE-2016-6662 for older versions).

```sql
SELECT @@version;
```

* File Access Privileges: Be warned about checking for FILE privileges, which could allow reading/writing files on the server.
```sql
SHOW GRANTS FOR CURRENT_USER;  -- Look for FILE privilege
```

---

## 7. Cleanup & reporting

* Return DB to original state if changes were made (use backups/snapshots).
* Create a report with:

  * How credentials were found or service exposed.
  * Severity (e.g., exposed credentials = critical).
  * Proof of concept (screenshots, safe query outputs).
  * Remediation steps and evidence after fixes.

---

## 8. Remediation checklist (teach these to students)

1. Remove DB credentials from webroot; store outside document root or in secret managers.
2. Ensure `wp-config.php` and `.env` are not accessible via HTTP and have tight permissions (`640` or `600`).
3. Bind MySQL to localhost or internal network (`bind-address = 127.0.0.1`) unless remote access is required.
4. Firewall: block port 3306 from Internet (`ufw deny 3306/tcp`) and only allow trusted IPs.
5. Use strong DB passwords and rotate compromised credentials.
6. Disable remote root login; create least-privilege DB users for apps.
7. Enable TLS for DB connections where possible.
8. Remove stale backups and `.sql` dumps from webroot.
9. Monitor connections and failed auth attempts; alert on anomalies.

---

## 9. Useful commands / tools summary

* Scanning & recon:

```bash
nmap -sV -p 3306 target
whatweb target
```

* Search for credentials on server:

```bash
grep -R "DB_PASSWORD" /var/www/html
find /var/www/html -iname "*.sql" -o -iname "*.env"
```

* DB client (lab):

```bash
mysql -u user -p -h host -P port
```

* SQLi testing (lab, non-destructive to start):

```bash
sqlmap -u "http://target/?id=1" --batch --level=1 --risk=1 --dbs
```

---

## 10. Student exercises

1. Passive: find DB creds in `wp-config.php` in a staging webroot copy.
2. Connection: use found creds to connect and list databases/tables (read-only).
3. Enumeration: export first 10 rows of `wp_users` and explain risk.
4. Hardening: apply `bind-address` + firewall rule and show that remote connection is blocked.
5. Forensics: produce a short report showing how access was gained and propose fixes.


Keep experiments non-destructive, treat DB access as high-value, meaning confidentiality and integrity.

---

# Why MSSQL ports (1433/tcp) might be open in hotels

Hospitality industry is notorious for cutting costs on IT and staff, this is why many smaller hotels still run on legacy PMS that require open MS-SQL ports.

Microsoft SQL Server (MS-SQL) is a widely used relational database engine by Microsoft that stores structured application data (users, transactions, reservations, configuration, etc.) and typically listens for client connections on TCP port 1433. Many legacy on-premises applications—including older desktop/server versions of hotel PMS software like Protel’s classic on-prem editions—were built to talk directly to an MS-SQL backend, and administrators or third-party integrators historically opened the database port for remote access or “quick” integrations rather than using VPNs or middleware. That convenience (plus misconfiguration, forgotten backups in webroots, or outsourced management practices) is why you still occasionally find MSSQL ports exposed today: a risky legacy pattern because it makes sensitive data and administrative interfaces reachable to the Internet; the safe modern approach is to restrict or remove direct exposure (use VPNs, IP whitelisting, internal-only bindings, or API/middleware layers instead).

Older PMS software (like early Protel desktop editions) sometimes expected remote offices, booking systems, or integrators to connect directly to the SQL Server over the internet. Instead of going through a VPN or middleware, integrators (e.g., booking engines, accounting software) were configured to “talk SQL” directly. So sys admins opened 1433 to allow external IT vendors to “just connect” instead of setting up secure tunnels. In hotels, it’s common to see outsourced IT with limited security practices. This kind of software is often marketed as "Reliable performance built on Microsoft SQL Server database", this should be treated as a red flag from cybersec perspective.

Also, interfaces for older channel managers, POS systems, or external booking portals sometimes required raw DB connectivity (before modern APIs existed).

So, an on-prem PMS (red flag!) still requiring open 1433 means it’s a legacy architecture problem that should be replaced, or at least mitigated with VPN and firewalling. If they succeed, they have direct access to customer data, reservations, payments, even ability to alter transactions. This is especially sensitive in hospitality, where guest data = GDPR / PCI liability.

```bash
# quick external check for mssql port
nmap -Pn -p 1433 target.example.com
# or more stealthy
nmap -sS -p 1433 --script ms-sql-info target.example.com
```

*Task for students:* Modify this nmap command to scan for ms-sql across a range of ports.

